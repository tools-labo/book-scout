<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BOOKスカウト｜ランキング</title>
  <link rel="stylesheet" href="./style.css" />
</head>
<body>
  <header class="header">
    <h1><a href="./index.html" style="color:inherit;text-decoration:none;">BOOKスカウト</a></h1>
    <p class="sub"><a href="./list.html" style="color:inherit;">← リストへ</a></p>
  </header>

  <main class="wrap">
    <div id="status" class="status"></div>

    <!-- 人気（閲覧数） -->
    <section class="section" style="margin-top:10px;">
      <div class="section-head">
        <h2 class="section-title">人気（閲覧数）</h2>
      </div>
      <p class="section-sub">作品詳細が表示された回数（同一セッションは1回）</p>
      <section id="rankViews" class="grid"></section>
    </section>

    <!-- お気に入り -->
    <section class="section" style="margin-top:18px;">
      <div class="section-head">
        <h2 class="section-title">お気に入り</h2>
      </div>
      <p class="section-sub">ONにした回数（端末ローカルのON操作のみカウント）</p>
      <section id="rankFav" class="grid"></section>
    </section>

    <!-- 投票（総合トップ3） -->
    <section class="section" style="margin-top:18px;">
      <div class="section-head">
        <h2 class="section-title">投票が多い作品（総合）</h2>
      </div>
      <p class="section-sub">人気ではなく「読み味データが集まっている」作品の確認用</p>
      <section id="rankVotesTotal" class="grid"></section>
    </section>

    <!-- 投票（気分別トップ3） -->
    <section class="section" style="margin-top:18px;">
      <div class="section-head">
        <h2 class="section-title">投票：気分別トップ3</h2>
      </div>
      <p class="section-sub">「泣ける」など各項目ごとに、投票が多い作品を3件だけ表示</p>
      <div id="voteByMoodBlocks"></div>
    </section>

    <!-- 運用確認（dev=1 のときだけ） -->
    <section id="devBox" class="section" style="margin-top:18px; display:none;">
      <div class="section-head">
        <h2 class="section-title">イベント種類（運用確認）</h2>
      </div>
      <div id="typeCounts" class="card" style="padding:12px;"></div>
    </section>
  </main>

  <script>
    function qs() { return new URLSearchParams(location.search); }

    async function loadJson(url, { bust = false } = {}) {
      const r = await fetch(url, { cache: bust ? "no-store" : "default" });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }

    function esc(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function toText(v) {
      if (v == null) return "";
      if (typeof v === "string") return v.trim();
      if (typeof v === "number" || typeof v === "boolean") return String(v);
      if (Array.isArray(v)) return v.map(toText).filter(Boolean).join(" / ");
      if (typeof v === "object") {
        const keys = ["title","name","label","value","text","display"];
        for (const k of keys) {
          if (v[k] != null) {
            const t = toText(v[k]);
            if (t) return t;
          }
        }
        return "";
      }
      return "";
    }

    function normalizeImgUrl(u) {
      const raw = toText(u);
      if (!raw) return "";
      let x = "";
      try { x = encodeURI(raw); } catch { x = raw; }
      x = x.replaceAll("+", "%2B");
      return x;
    }

    function setStatus(msg) {
      const s = document.getElementById("status");
      if (s) s.textContent = msg;
    }

    function getWorkMap(items) {
      const map = new Map();
      for (const it of (items || [])) {
        const seriesKey = toText(it?.seriesKey);
        if (!seriesKey) continue;
        map.set(seriesKey, it);
      }
      return map;
    }

    function cardHtml({ seriesKey, n, work }) {
      const key = encodeURIComponent(seriesKey);
      const title = toText(work?.vol1?.title) || seriesKey;
      const img = normalizeImgUrl(toText(work?.vol1?.image));
      const author = toText(work?.vol1?.author);
      const publisher = toText(work?.vol1?.publisher);

      const meta = [author, publisher].filter(Boolean).join(" / ");

      return `
        <article class="card">
          <div class="card-row">
            <div class="thumb">
              ${img ? `<a href="./work.html?key=${key}"><img src="${esc(img)}" alt="${esc(title)}"/></a>` : `<div class="thumb-ph"></div>`}
            </div>
            <div class="meta">
              <div class="title"><a href="./work.html?key=${key}">${esc(seriesKey)}</a></div>
              ${meta ? `<div class="sub">${esc(meta)}</div>` : ""}
              <div class="sub">回数: <b>${esc(n)}</b></div>
            </div>
          </div>
        </article>
      `;
    }

    function kvListHtml(rows, labelKey, valueKey) {
      if (!rows?.length) return `<div class="status">データがまだありません</div>`;
      const lines = rows.map(r => {
        const k = toText(r?.[labelKey]);
        const v = toText(r?.[valueKey]);
        return `<div style="display:flex;justify-content:space-between;gap:10px;padding:6px 0;border-bottom:1px solid var(--line);">
          <div>${esc(k || "-")}</div>
          <div style="font-variant-numeric:tabular-nums;white-space:nowrap;"><b>${esc(v || "0")}</b></div>
        </div>`;
      }).join("");
      return `<div>${lines}</div>`;
    }

    // quick_filters の id -> label
    function moodLabelMap(quickItems) {
      const map = new Map();
      for (const it of (quickItems || [])) {
        const id = toText(it?.id);
        const label = toText(it?.label);
        if (id) map.set(id, label || id);
      }
      return map;
    }

    function groupTop3ByMood(rows) {
      // rows: [{mood, seriesKey, n}, ...] で moodごとに n降順
      const by = new Map();
      for (const r of (rows || [])) {
        const mood = toText(r?.mood);
        const seriesKey = toText(r?.seriesKey);
        const n = Number(toText(r?.n) || "0");
        if (!mood || !seriesKey) continue;
        if (!by.has(mood)) by.set(mood, []);
        by.get(mood).push({ seriesKey, n });
      }
      for (const [m, arr] of by.entries()) {
        arr.sort((a,b) => b.n - a.n);
        by.set(m, arr.slice(0, 3));
      }
      return by;
    }

    async function run() {
      try {
        const v = qs().get("v");
        const bust = !!v;
        const vq = v ? `?v=${encodeURIComponent(v)}` : "";

        const isDev = qs().get("dev") === "1";
        const devBox = document.getElementById("devBox");
        if (devBox) devBox.style.display = isDev ? "" : "none";

        // works（作品情報）
        const works = await loadJson(`./data/lane2/works.json${vq}`, { bust });
        const workMap = getWorkMap(works?.items || []);

        // quick filters（mood日本語ラベル）
        const quick = await loadJson(`./data/lane2/quick_filters.json${vq}`, { bust });
        const quickItems = Array.isArray(quick?.items) ? quick.items : [];
        const moodLabels = moodLabelMap(quickItems);

        // metrics
        const typeCounts = isDev
          ? await loadJson(`./data/metrics/wae/type_counts.json${vq}`, { bust }).catch(() => null)
          : null;

        const viewBySeries = await loadJson(`./data/metrics/wae/work_view_by_series.json${vq}`, { bust }).catch(() => null);
        const favBySeries = await loadJson(`./data/metrics/wae/favorite_by_series.json${vq}`, { bust }).catch(() => null);

        const voteBySeries = await loadJson(`./data/metrics/wae/vote_by_series.json${vq}`, { bust }).catch(() => null);
        const voteByMoodSeries = await loadJson(`./data/metrics/wae/vote_by_mood_series.json${vq}`, { bust }).catch(() => null);

        // 人気（閲覧数）トップ3
        {
          const root = document.getElementById("rankViews");
          const rows = Array.isArray(viewBySeries?.rows) ? viewBySeries.rows : [];
          if (!root) {}
          else if (!rows?.length) root.innerHTML = `<div class="status">データがまだありません</div>`;
          else {
            const top = rows.slice(0, 3).map(r => {
              const seriesKey = toText(r?.seriesKey);
              const n = toText(r?.n);
              const work = workMap.get(seriesKey);
              return seriesKey ? cardHtml({ seriesKey, n, work }) : "";
            }).join("");
            root.innerHTML = top || `<div class="status">データがまだありません</div>`;
          }
        }

        // お気に入り トップ3
        {
          const root = document.getElementById("rankFav");
          const rows = Array.isArray(favBySeries?.rows) ? favBySeries.rows : [];
          if (!root) {}
          else if (!rows?.length) root.innerHTML = `<div class="status">データがまだありません</div>`;
          else {
            const top = rows.slice(0, 3).map(r => {
              const seriesKey = toText(r?.seriesKey);
              const n = toText(r?.n);
              const work = workMap.get(seriesKey);
              return seriesKey ? cardHtml({ seriesKey, n, work }) : "";
            }).join("");
            root.innerHTML = top || `<div class="status">データがまだありません</div>`;
          }
        }

        // 投票が多い作品（総合）トップ3
        {
          const root = document.getElementById("rankVotesTotal");
          const rows = Array.isArray(voteBySeries?.rows) ? voteBySeries.rows : [];
          if (!root) {}
          else if (!rows?.length) root.innerHTML = `<div class="status">データがまだありません</div>`;
          else {
            const top = rows.slice(0, 3).map(r => {
              const seriesKey = toText(r?.seriesKey);
              const n = toText(r?.n);
              const work = workMap.get(seriesKey);
              return seriesKey ? cardHtml({ seriesKey, n, work }) : "";
            }).join("");
            root.innerHTML = top || `<div class="status">データがまだありません</div>`;
          }
        }

        // 投票：気分別トップ3（9項目）
        {
          const box = document.getElementById("voteByMoodBlocks");
          const rows = Array.isArray(voteByMoodSeries?.rows) ? voteByMoodSeries.rows : [];
          if (!box) {}
          else if (!rows?.length) {
            box.innerHTML = `<div class="status">データがまだありません</div>`;
          } else {
            const grouped = groupTop3ByMood(rows);

            // quick_filters の並び順を優先（存在しないmoodは無視）
            const orderedIds = quickItems.map(x => toText(x?.id)).filter(Boolean);

            const blocks = orderedIds.map((moodId) => {
              const list = grouped.get(moodId) || [];
              const label = moodLabels.get(moodId) || moodId;

              const inner = list.length
                ? `<section class="grid">${list.map(x => {
                    const work = workMap.get(x.seriesKey);
                    return cardHtml({ seriesKey: x.seriesKey, n: String(x.n), work });
                  }).join("")}</section>`
                : `<div class="status">データがまだありません</div>`;

              return `
                <section class="section" style="margin-top:12px;">
                  <div class="section-head">
                    <h3 class="section-title" style="font-size:16px;">${esc(label)} トップ3</h3>
                  </div>
                  ${inner}
                </section>
              `;
            }).join("");

            box.innerHTML = blocks || `<div class="status">データがまだありません</div>`;
          }
        }

        // dev: type別（開発中だけ）
        if (isDev) {
          const box = document.getElementById("typeCounts");
          const rows = Array.isArray(typeCounts?.rows) ? typeCounts.rows : [];
          if (box) box.innerHTML = kvListHtml(rows.slice(0, 50), "type", "n");
        }

        setStatus("");
      } catch (e) {
        console.error(e);
        setStatus("集計データの読み込みに失敗しました（まだJSONが無い可能性あり）");
      }
    }

    run();
  </script>
</body>
</html>
