<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BOOKスカウト｜ランキング</title>
  <link rel="stylesheet" href="./style.css" />
  <style>
    /* stats専用の見た目強化（既存style.cssを壊さない） */
    .rank-card { position: relative; }
    .rank-badge{
      position:absolute;
      top:10px; left:10px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height:26px;
      padding:0 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.06);
      color: var(--fg);
      font-weight: 900;
      font-size: 12px;
      letter-spacing: .02em;
      backdrop-filter: blur(6px);
    }
    .rank-count{
      position:absolute;
      top:10px; right:10px;
      display:inline-flex;
      align-items:baseline;
      gap:6px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(43,97,255,0.12);
      backdrop-filter: blur(6px);
    }
    .rank-count .num{
      font-weight: 1000;
      font-size: 20px;
      line-height: 1;
      font-variant-numeric: tabular-nums;
    }
    .rank-count .unit{
      color: var(--muted);
      font-size: 12px;
      font-weight: 800;
      line-height: 1;
    }
    .rank-meta-strong{
      margin-top: 2px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    .subnote{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.55;
      margin: 6px 0 10px;
    }

    .mood-section{
      border:1px solid var(--line);
      border-radius: 14px;
      background: rgba(255,255,255,0.02);
      padding: 12px;
      margin-top: 12px;
    }
    .mood-head{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .mood-title{
      margin:0;
      font-size: 16px;
      font-weight: 1000;
    }
    .mood-total{
      color: var(--muted);
      font-size: 12px;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <header class="header">
    <h1><a href="./index.html" style="color:inherit;text-decoration:none;">BOOKスカウト</a></h1>
    <p class="sub"><a href="./list.html" style="color:inherit;">← リストへ</a></p>
  </header>

  <main class="wrap">
    <div id="status" class="status"></div>

    <!-- 人気（閲覧数） -->
    <section class="section" style="margin-top:10px;">
      <div class="section-head">
        <h2 class="section-title">人気（閲覧数）</h2>
      </div>
      <p class="section-sub">作品詳細が表示された回数（同一セッションは1回）</p>
      <section id="rankViews" class="grid"></section>
    </section>

    <!-- お気に入り -->
    <section class="section" style="margin-top:18px;">
      <div class="section-head">
        <h2 class="section-title">お気に入り</h2>
      </div>
      <p class="section-sub">ONにした回数（端末ローカルのON操作のみカウント）</p>
      <section id="rankFav" class="grid"></section>
    </section>

    <!-- 投票（総合Top3） -->
    <section class="section" style="margin-top:18px;">
      <div class="section-head">
        <h2 class="section-title">投票が多い作品（総合Top3）</h2>
      </div>
      <p class="section-sub">人気ではなく「読み味データが集まっている」作品の確認用</p>
      <section id="rankVotesTop" class="grid"></section>
    </section>

    <!-- 投票：気分別トップ3（直近200のvoteから作る） -->
    <section class="section" style="margin-top:18px;">
      <div class="section-head">
        <h2 class="section-title">投票：気分別トップ3</h2>
      </div>
      <div class="subnote">
        直近の投票（recent_200）から作る暫定ランキング。あとで「mood×作品」の集計JSONを自動生成すれば、全期間の正確なTop3にできます。
      </div>
      <div id="voteByMoodTop3"></div>
    </section>

    <!-- 運用確認（イベント種類）※開発終わったら撤去想定 -->
    <section class="section" style="margin-top:18px;">
      <div class="section-head">
        <h2 class="section-title">イベント種類（運用確認）</h2>
      </div>
      <div id="typeCounts" class="card" style="padding:12px;"></div>
    </section>
  </main>

  <script>
    function qs() { return new URLSearchParams(location.search); }

    async function loadJson(url, { bust = false } = {}) {
      const r = await fetch(url, { cache: bust ? "no-store" : "default" });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }

    function esc(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function toText(v) {
      if (v == null) return "";
      if (typeof v === "string") return v.trim();
      if (typeof v === "number" || typeof v === "boolean") return String(v);

      if (Array.isArray(v)) {
        const xs = v.map(toText).filter(Boolean);
        const seen = new Set();
        const uniq = xs.filter(x => (seen.has(x) ? false : (seen.add(x), true)));
        return uniq.join(" / ");
      }

      if (typeof v === "object") {
        const keys = ["name","ja","jp","label","value","text","title","publisher","company","display","brand","manufacturer"];
        for (const k of keys) {
          if (v[k] != null) {
            const t = toText(v[k]);
            if (t) return t;
          }
        }
        return "";
      }
      return "";
    }

    function pick(it, keys) {
      for (const k of keys) {
        const v = k.includes(".")
          ? k.split(".").reduce((o, kk) => (o ? o[kk] : undefined), it)
          : it?.[k];
        if (Array.isArray(v)) return v;
        if (toText(v)) return v;
      }
      return null;
    }

    function pickArr(it, keys) {
      for (const k of keys) {
        const v = k.includes(".")
          ? k.split(".").reduce((o, kk) => (o ? o[kk] : undefined), it)
          : it?.[k];
        if (Array.isArray(v) && v.length) return v;
      }
      return [];
    }

    function formatYmd(s) {
      const t = toText(s);
      if (!t) return "";
      if (t.length >= 10 && /^\d{4}-\d{2}-\d{2}/.test(t)) return t.slice(0, 10);
      return t;
    }

    function normalizeImgUrl(u) {
      const raw = toText(u);
      if (!raw) return "";
      let x = "";
      try { x = encodeURI(raw); } catch { x = raw; }
      x = x.replaceAll("+", "%2B");
      return x;
    }

    function setStatus(msg) {
      const s = document.getElementById("status");
      if (s) s.textContent = msg;
    }

    const GENRE_JA = {
      Action: "アクション",
      Adventure: "冒険",
      Comedy: "コメディ",
      Drama: "ドラマ",
      Fantasy: "ファンタジー",
      Horror: "ホラー",
      Mystery: "ミステリー",
      Psychological: "心理",
      Romance: "恋愛",
      "Sci-Fi": "SF",
      "Slice of Life": "日常",
      Sports: "スポーツ",
      Supernatural: "超常",
      Thriller: "サスペンス",
    };

    function mapGenres(genres) {
      if (!Array.isArray(genres)) return [];
      return genres
        .map((g) => {
          const s = toText(g);
          if (!s) return null;
          if (GENRE_JA[s] == null && /[ぁ-んァ-ヶ一-龠]/.test(s)) return s;
          return GENRE_JA[s] || null;
        })
        .filter(Boolean);
    }

    function pills(list) {
      const xs = (list || []).map(toText).filter(Boolean);
      if (!xs.length) return "";
      return `<div class="pills">${xs.map(x => `<span class="pill">${esc(x)}</span>`).join("")}</div>`;
    }

    function pickRows(obj) {
      if (!obj) return [];
      if (Array.isArray(obj)) return obj;
      if (Array.isArray(obj?.rows)) return obj.rows;
      if (Array.isArray(obj?.data)) return obj.data;
      return [];
    }

    function getWorkMap(items) {
      const map = new Map();
      for (const it of (items || [])) {
        const seriesKey = toText(pick(it, ["seriesKey"]));
        if (!seriesKey) continue;
        map.set(seriesKey, it);
      }
      return map;
    }

    function getMoodLabelMap(quick) {
      const map = new Map();
      const defs = Array.isArray(quick?.items) ? quick.items : [];
      for (const d of defs) {
        const id = toText(d?.id);
        const label = toText(d?.label);
        if (id) map.set(id, label || id);
      }
      return map;
    }

    function rankCardHtml({ rank, seriesKey, n, work }) {
      const key = encodeURIComponent(seriesKey);

      const title = toText(pick(work, ["title", "vol1.title"])) || seriesKey || "(無題)";
      const author = toText(pick(work, ["author", "vol1.author"])) || "";
      const release = formatYmd(pick(work, ["releaseDate", "vol1.releaseDate"])) || "";
      const publisher = toText(pick(work, ["publisher", "vol1.publisher"])) || "";
      const magazine = toText(pick(work, ["magazine", "vol1.magazine"])) || "";

      const imgRaw = toText(pick(work, ["image", "vol1.image"])) || "";
      const img = normalizeImgUrl(imgRaw);

      const genresJa = mapGenres(pickArr(work, ["genres", "vol1.genres"]));
      const tagsJa = pickArr(work, ["tags", "vol1.tags"]).slice(0, 10).map(toText).filter(Boolean);

      const synopsis = toText(pick(work, ["synopsis", "vol1.synopsis"])) || "";

      const metaParts = [
        author ? author : null,
        release ? `発売日: ${release}` : null,
        publisher ? `出版社: ${publisher}` : null,
        magazine ? `連載誌: ${magazine}` : null,
      ].filter(Boolean).join(" / ");

      return `
        <article class="card rank-card">
          <div class="rank-badge">#${esc(rank)}</div>
          <div class="rank-count"><span class="num">${esc(n)}</span><span class="unit">回</span></div>

          <div class="card-row">
            <div class="thumb">
              ${img
                ? `<a href="./work.html?key=${key}"><img src="${esc(img)}" alt="${esc(title)}"/></a>`
                : `<div class="thumb-ph"></div>`
              }
            </div>
            <div class="meta">
              <div class="title"><a href="./work.html?key=${key}">${esc(seriesKey || title)}</a></div>
              ${metaParts ? `<div class="sub">${esc(metaParts)}</div>` : ""}

              ${genresJa.length ? `<div class="sub">ジャンル: ${esc(genresJa.join(" / "))}</div>` : ""}
              ${tagsJa.length ? `<div class="sub">タグ:</div>${pills(tagsJa)}` : ""}

              ${synopsis ? `
                <details class="syn">
                  <summary>あらすじ</summary>
                  <div class="syn-body">${esc(synopsis)}</div>
                </details>
              ` : ""}
            </div>
          </div>
        </article>
      `;
    }

    function kvListHtml(rows, labelKey, valueKey) {
      if (!rows?.length) return `<div class="status">データがまだありません</div>`;
      const lines = rows.map(r => {
        const k = toText(r?.[labelKey]);
        const v = toText(r?.[valueKey]);
        return `<div style="display:flex;justify-content:space-between;gap:10px;padding:6px 0;border-bottom:1px solid var(--line);">
          <div>${esc(k || "-")}</div>
          <div style="font-variant-numeric:tabular-nums;white-space:nowrap;"><b>${esc(v || "0")}</b></div>
        </div>`;
      }).join("");
      return `<div>${lines}</div>`;
    }

    // recent_200 から vote を集計して mood別トップ3を作る
    function buildVoteMoodTop3({ recentRows, moodLabelMap }) {
      // mood -> (seriesKey -> count)
      const moodMap = new Map();

      for (const r of (recentRows || [])) {
        const type = toText(r?.type);
        if (type !== "vote") continue;

        const seriesKey = toText(r?.seriesKey);
        const mood = toText(r?.mood);
        if (!seriesKey || !mood) continue;

        if (!moodMap.has(mood)) moodMap.set(mood, new Map());
        const bySeries = moodMap.get(mood);

        bySeries.set(seriesKey, (bySeries.get(seriesKey) || 0) + 1);
      }

      // moodごとの総数も作る
      const out = [];
      for (const [mood, bySeries] of moodMap.entries()) {
        let total = 0;
        const arr = [];
        for (const [seriesKey, n] of bySeries.entries()) {
          total += n;
          arr.push({ seriesKey, n });
        }
        arr.sort((a, b) => (b.n - a.n) || a.seriesKey.localeCompare(b.seriesKey, "ja"));

        out.push({
          mood,
          label: moodLabelMap.get(mood) || mood,
          total,
          top3: arr.slice(0, 3),
        });
      }

      // 総投票が多い気分順
      out.sort((a, b) => (b.total - a.total) || a.label.localeCompare(b.label, "ja"));
      return out;
    }

    async function run() {
      try {
        const v = qs().get("v");
        const bust = !!v;
        const vq = v ? `?v=${encodeURIComponent(v)}` : "";

        const works = await loadJson(`./data/lane2/works.json${vq}`, { bust });
        const workMap = getWorkMap(works?.items || []);

        const quick = await loadJson(`./data/lane2/quick_filters.json${vq}`, { bust }).catch(() => null);
        const moodLabel = getMoodLabelMap(quick);

        const typeCounts = await loadJson(`./data/metrics/wae/type_counts.json${vq}`, { bust }).catch(() => null);
        const viewBySeries = await loadJson(`./data/metrics/wae/work_view_by_series.json${vq}`, { bust }).catch(() => null);
        const favBySeries = await loadJson(`./data/metrics/wae/favorite_by_series.json${vq}`, { bust }).catch(() => null);
        const voteBySeries = await loadJson(`./data/metrics/wae/vote_by_series.json${vq}`, { bust }).catch(() => null);
        const recent200 = await loadJson(`./data/metrics/wae/recent_200.json${vq}`, { bust }).catch(() => null);

        // 人気（閲覧数）
        {
          const root = document.getElementById("rankViews");
          const rows = pickRows(viewBySeries);
          if (!root) {}
          else if (!rows.length) root.innerHTML = `<div class="status">データがまだありません</div>`;
          else {
            const top = rows.slice(0, 30).map((r, i) => {
              const seriesKey = toText(r?.seriesKey);
              const n = toText(r?.n);
              const work = workMap.get(seriesKey);
              return seriesKey ? rankCardHtml({ rank: i + 1, seriesKey, n, work }) : "";
            }).join("");
            root.innerHTML = top || `<div class="status">データがまだありません</div>`;
          }
        }

        // お気に入り
        {
          const root = document.getElementById("rankFav");
          const rows = pickRows(favBySeries);
          if (!root) {}
          else if (!rows.length) root.innerHTML = `<div class="status">データがまだありません</div>`;
          else {
            const top = rows.slice(0, 30).map((r, i) => {
              const seriesKey = toText(r?.seriesKey);
              const n = toText(r?.n);
              const work = workMap.get(seriesKey);
              return seriesKey ? rankCardHtml({ rank: i + 1, seriesKey, n, work }) : "";
            }).join("");
            root.innerHTML = top || `<div class="status">データがまだありません</div>`;
          }
        }

        // 投票（総合Top3）※要望通りトップ3
        {
          const root = document.getElementById("rankVotesTop");
          const rows = pickRows(voteBySeries);
          if (!root) {}
          else if (!rows.length) root.innerHTML = `<div class="status">データがまだありません</div>`;
          else {
            const top = rows.slice(0, 3).map((r, i) => {
              const seriesKey = toText(r?.seriesKey);
              const n = toText(r?.n);
              const work = workMap.get(seriesKey);
              return seriesKey ? rankCardHtml({ rank: i + 1, seriesKey, n, work }) : "";
            }).join("");
            root.innerHTML = top || `<div class="status">データがまだありません</div>`;
          }
        }

        // 投票：気分別トップ3（recent_200から暫定生成）
        {
          const root = document.getElementById("voteByMoodTop3");
          const rows = pickRows(recent200);
          const moods = buildVoteMoodTop3({ recentRows: rows, moodLabelMap: moodLabel });

          if (!root) {}
          else if (!moods.length) {
            root.innerHTML = `<div class="status">データがまだありません</div>`;
          } else {
            root.innerHTML = moods.map(m => {
              const cards = m.top3.map((x, idx) => {
                const work = workMap.get(x.seriesKey);
                return rankCardHtml({ rank: idx + 1, seriesKey: x.seriesKey, n: x.n, work });
              }).join("");

              return `
                <section class="mood-section">
                  <div class="mood-head">
                    <h3 class="mood-title">${esc(m.label)}</h3>
                    <div class="mood-total">直近投票: <b>${esc(m.total)}</b></div>
                  </div>
                  <div class="grid">${cards || `<div class="status">該当なし</div>`}</div>
                </section>
              `;
            }).join("");
          }
        }

        // type別（運用確認）
        {
          const box = document.getElementById("typeCounts");
          const rows = pickRows(typeCounts);
          if (box) box.innerHTML = kvListHtml(rows.slice(0, 50), "type", "n");
        }

        setStatus("");
      } catch (e) {
        console.error(e);
        setStatus("集計データの読み込みに失敗しました（まだJSONが無い可能性あり）");
      }
    }

    run();
  </script>
</body>
</html>
